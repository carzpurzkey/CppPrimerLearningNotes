# 第二章 变量和基本类型
1. 算术类型

    | 类型            | 含义               | 最小尺寸           |
    | --------------- |:------------------:| ------------------:|
    | bool            | 布尔类型           | 未定义             |
    | char            | 字符               | 8位                |
    | wchar_t         | 宽字符             | 16位               |
    | char16_t        | Unicode字符        | 16位               |
    | char32_t        | Unicode字符        | 32位               |
    | short           | 短整型             | 16位               |
    | int             | 整型               | 16位               |
    | long            | 长整型             | 32位               |
    | long long       | 长整型             | 64位               |
    | float           | 单精度浮点数       | 6位有效数字        |
    | double          | 双精度浮点数       | 10位有效数字       |
    | long double     | 扩展精度浮点数     | 10位有效数字       |（P30）
    
    * 从上表可以看出char16_t和char32_t分别最少有16位和32位，他们的值没有符号，属于无符号整形。可以用sizeof表达式得到编译器中他们的实际大小。char16_t是用来支持国际通用字符集（Universal Character Set，也叫Unicode）的UCS-2/UTF-16编码，char32_t是用来支持Unicode的UCS-4/UTF-32编码。和char一样，C++标准并没有规定wchar_t是有符号的还是无符号的，wchar_t至少有16位，他是用来支持执行宽字符集（execution wide character set）的。不严格的说，C++中的执行宽字符集所支持的字符需要囊括源代码中可能用到的所有字符。wchar_t和char16_t不同的是，执行宽字符集（即wchar_t）可以是Unicode，但也可以不是，是编译器自定义的行为。
    * 你也许好奇为什么这些命名和前面的int，char之类的不太一样，后面都跟着一个 _t，这其实是C语言的传统。C的程序员习惯把用户自定义的类型都加上 _t这个后缀，表示类型（type）。char16_t，char32_t和wchar_t 算是C语言标准规定的用户自定义类型，但他们只算“二等公民”。他们其实分别和某一个前面提到过的整型（“一等公民”）是同一种类型。C++中直接将这些类型提升为“一等公民”，他们在C++中和其他的整型属于不同的类型。但为了保持C的兼容，所以C++中也用 _t这个后缀。
    * 宽字符字面值常量wchar_t也可以文本输出，但输出前要定义正确的编码方式。以Windows为例，虽然wchar_t采用Unicode编码，Windows输出时采用的编码并不是Unicode，而是你在Windows设置中设置的本地化的语言编码。如果是中文，就是GB18030编码（GB18030兼容GB2312和GBK，这些编码和Unicode编码不同，即同一个汉字所映射的整数值不同），程序会自动将Unicode转换成本地化的语言编码。
    * char16_t和char32_t并不能像wchar_t一样直接用wcout作文本输出，他们是用来支持Unicode的各种编码，解码以及文档读取和存储等操作的，并不适合作文本输出（但他们可以用二进制形式输出）。宽字符的文本形式输出是和编译器内部的执行字符编码以及用户设置的本地化编码方式紧密相关的，所以用wchar_t更自然一些，因为wchar_t本身就是实现自定义的行为，不同的编译器可以用不同的执行字符编码以及采用不同的执行字符编码到用户设置的本地化编码的转换。
    * 字符型分为三种：char，signed char和unsigned char。** 类型char和signed char **不一样：类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。
    * 8 bit的signed char理论上应该可以表示-127至127区间的值，大多数现代计算机将实际的表示范围定为-128至127。
    * 如何选择类型：
        * 当明确知晓数值不可能能为负时，选用无符号类型。
        * 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
        * 在算术表达式中不要使用char 或bool，只有在存放字符或布尔值时才使用它们。因为char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是unsigned char或者signed char。
        * 执行浮点数运算选用double，这是因为float通常精度不够而且双精度和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
* 类型转换

    ```C++
    bool b = 42;               //b为真
    int i = b;                 //i的值为1
    i = 3.14;                  //i的值为3
    double pi = i;             //pi的值为3.0
    unsigned char c = -1;      //假设char占8 bit，c的值为255
    signed char c = 256;       //假设char占8 bit，c的值是未定义的
    ```
